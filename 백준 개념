1. 배열(IntArray) vs. 가변 리스트(MutableList)의 차이
IntArray (배열):
IntArray는 크기가 고정된 원시 타입 배열입니다.

배열은 고정된 크기를 갖기 때문에 메모리 상에서 직접적인 접근이 가능하고, 수정과 조회가 매우 빠릅니다.

IntArray는 메모리 효율이 높고, 컴파일러 최적화가 잘 이루어집니다.

MutableList (가변 리스트):
MutableList는 크기가 동적으로 변할 수 있는 리스트입니다.

내부적으로 배열을 사용하여 값을 저장하지만, 리스트는 동적 크기 조정이 가능하고, 추가, 삭제, 삽입 등의 연산을 지원하기 위해 추가적인 메커니즘이 필요합니다.

성능이 배열보다 다소 떨어질 수 있습니다, 특히 크기가 자주 변하는 경우.

2. 성능 차이가 나는 이유:
배열 (IntArray)은 고정된 크기와 원시 타입을 사용하기 때문에, 정렬 같은 연산을 할 때 메모리 접근이 빠르고 효율적입니다.

가변 리스트 (mutableListOf<Int>)는 배열을 기반으로 하더라도, 크기 조정 및 동적 변경을 지원해야 하므로 추가적인 오버헤드가 발생할 수 있습니다. 예를 들어, 요소를 추가할 때 add() 함수가 내부적으로 배열을 확장하는 과정을 거칠 수 있고, 그로 인해 성능에 약간의 오버헤드가 발생할 수 있습니다.

3. 메모리 사용 차이:
IntArray는 원시 배열이기 때문에, 메모리 사용이 더 효율적입니다. 즉, 각 요소는 정수값만을 저장합니다.

MutableList는 동적 리스트이므로, 요소를 저장하는 데 추가적인 객체 구조가 필요하고, 이로 인해 메모리 사용에서 약간의 추가 오버헤드가 발생할 수 있습니다.

4. 정렬 차이:
IntArray에서 sort()는 배열을 직접 정렬하기 때문에 성능이 좋습니다.

MutableList에서 sort()는 리스트 요소를 일시적으로 배열로 변환할 수 있는데, 그로 인해 배열로 변환하는 과정이 추가로 필요할 수 있습니다. 이 과정에서 약간의 시간이 더 걸릴 수 있습니다.

결론:
**배열(IntArray)**을 사용하는 경우 메모리와 성능 측면에서 더 효율적입니다.

**가변 리스트(MutableList)**는 크기가 동적으로 변경될 수 있기 때문에 더 유연하지만, 성능 면에서 약간의 오버헤드가 있을 수 있습니다.

따라서, IntArray를 사용하는 코드가 더 빠른 이유는 배열이 고정 크기의 원시 타입을 사용하며, 더 적은 오버헤드를 발생시키기 때문입니다. MutableList는 동적 크기 변경을 지원하지만, 그로 인한 메모리 오버헤드나 성능 저하가 있을 수 있습니다.
//array와 가변리스트는 sort()를 사용하고 불변리스트는 sorted()를 사용한다!!!!!!!!!!




3. readLine() vs nextXXX() 비교
구분	readLine()	nextXXX()
반환 타입	String (문자열)	Int, Double, String (자료형에 따라 다름)
입력 형식	한 줄의 입력을 문자열로 받음	공백으로 구분된 한 개의 값만 입력받을 수 있음
형변환	문자열을 명시적으로 형변환해야 함	자동으로 형변환 처리
공백 처리	공백을 포함한 전체 입력을 처리 가능	공백을 기준으로 값을 나누어 읽음
반복 입력	여러 줄 입력을 받기 위해서는 반복문이 필요	nextXXX()를 반복문 내에서 여러 번 호출해야 함
예외 처리	입력된 값에 대한 검증을 명시적으로 해야 함	잘못된 입력 시 예외 발생 가능 (InputMismatchException)
성능	비교적 느릴 수 있음 (문자열 처리)	빠른 입력 처리
주로 사용되는 경우	복잡한 데이터, 여러 값, 사용자로부터 전체 한 줄 입력을 받을 때	간단한 값 입력 (정수, 실수 등)

4. 어떤 경우에 어떤 방법을 사용할지:
readLine()을 사용하는 경우:

사용자로부터 전체 한 줄의 입력을 받을 때.

입력받은 데이터를 다양한 방식으로 처리해야 할 때 (예: 공백으로 구분된 값들을 파싱하고 계산하는 경우).

동적 입력이 필요한 경우.

nextXXX()을 사용하는 경우:

단일 값을 입력받을 때, 예를 들어 정수, 실수, 문자열 등.

속도가 중요한 경우, 여러 개의 입력을 한 번에 받아 처리해야 할 때.

입력되는 데이터 타입이 확실하고, 자동으로 형변환이 필요한 경우.

결론:
**readLine()**은 유연하고 자유롭게 다양한 형식의 데이터를 처리할 수 있지만, 형변환과 공백 처리에 신경 써야 합니다.

**nextXXX()**는 정확한 타입을 읽어오기 편리하며, 빠르고 안전하게 처리할 수 있지만, 단일 값 처리에 제한이 있고 공백을 처리하는 데 제약이 있습니다.


+++++따라서 map 함수의 결과는 각 문자에 대한 String을 모은 **List<String>**입니다.+++++




+++++BigInteger 생성자는 String 타입을 받아야 하는데, nextInt()는 Int를 반환합니다.
즉, 아래 코드는 잘못된 생성자 사용입니다:
BigInteger(Int) ❌  // 존재하지 않는 생성자+++++


내부 구현 최적화:

**A == B**는 일반적으로 더 최적화된 경로를 따릅니다. 예를 들어, 두 BigInteger 객체의 크기가 다를 경우 바로 false를 반환할 수 있는데, 이 과정이 더 최적화되어 있어서 빠르게 종료됩니다.

반면 **A != B**는 ==를 먼저 평가하고 그 결과를 반전시키는 방식으로 구현되므로 두 조건을 모두 평가해야 할 때 시간이 더 걸릴 수 있습니다.

최악의 경우:

**A != B**는 두 숫자가 같을 때 모든 자릿수를 비교해야 하므로 끝까지 비교해야 하고, 이 과정에서 BigInteger의 모든 자리 수를 다 확인하는 비용이 발생할 수 있습니다. 반면 A == B는 숫자가 같다는 것을 최적화된 경로로 체크할 수 있기 때문에 더 빠를 수 있습니다.

메모리 캐시와 성능 최적화:

실제로 JVM에서 BigInteger 클래스는 여러 가지 최적화가 적용되어 있는데, A == B와 같은 비교 연산은 캐시 효율성 등에서 유리할 수 있습니다. A != B는 더 많은 경우를 고려해야 하므로, 내부적으로 더 많은 분기점을 고려해야 하므로 더 느릴 수 있습니다.

결론:
A == B가 더 빠르다는 결과는 BigInteger의 최적화나 JVM의 성능 최적화에 의한 것입니다.

A != B는 내부적으로 A == B의 결과를 반전시키는 작업을 거쳐야 하므로 약간 더 복잡하고 느릴 수 있습니다.

비교가 빠르게 종료될 수 있는 경우와 최적화된 경로 때문에 A == B가 더 빠르게 처리될 가능성이 있습니다.

따라서, 실제로는 A == B가 더 빠를 수 있으며, 이는 BigInteger 비교의 특성과 JVM 최적화 방식에 의한 결과입니다.


핵심 차이: 버퍼 처리와 출력 타이밍
✅ println()
줄바꿈 문자(\n)를 포함한 출력.

출력 버퍼를 자동으로 flush(비우는)할 가능성이 낮음.

즉, 여러 println() 호출이 하나의 I/O 버퍼에 모여 있다가 한 번에 출력될 수 있음.

⚠️ print()
줄바꿈이 없기 때문에, 버퍼가 꽉 차기 전까지 flush되지 않을 수 있음.

또는, 일부 환경(콘솔, 디버깅 도구 등)에서는 print() 직후 flush가 자동 발생하는 경우도 있어, 오히려 I/O가 더 자주 일어나 느려질 수 있음.



Scanner의 nextInt()와 nextLine()을 순차적으로 사용할 때 입력 버퍼에 남아 있는 **개행 문자(\n)**가 문제가 됩니다.

nextInt()로 숫자를 입력받고 나면 개행 문자(\n)가 버퍼에 남습니다.

nextLine()을 호출하면 그 개행 문자가 먼저 읽히고, 그다음 줄이 비어있기 때문에 빈 문자열을 읽게 됩니다.

이 문제를 해결하려면 nextInt() 후에 nextLine()을 한 번 더 호출하여 남은 개행 문자를 처리해야 합니다.



"""로 감싸진 Kotlin의 raw string에서는 ${"$"}처럼 이중 이스케이프를 통해 $를 출력하고 있어.

Kotlin의 문자열 안에서 ${...}는 문자열 템플릿 문법이기 때문에 $ 자체를 문자열로 출력하고 싶다면:

일반 문자열 ("...")에서는 "\$"

raw 문자열 ("""...""")에서는 "${"$"}"로 써야 해

nextLine()은 입력 스트림에서 줄바꿈 문자 \n을 기준으로 한 줄을 읽고, 읽은 뒤 줄바꿈 문자는 버린다는 특징이 있습니다.

예를 들어, 사용자 입력이 아래와 같다고 할 때:

python
복사
편집
abc
def
다음 코드가 실행되면:
val line1 = scanner.nextLine()  // 첫 번째 줄 "abc"를 읽고 \n은 버림
val line2 = scanner.nextLine()  // 두 번째 줄 "def"를 읽고 \n은 버림
line1은 "abc"로 저장되고,

line2는 "def"로 저장됩니다.

즉, nextLine()은 줄바꿈을 읽지 않지만, 줄바꿈을 소비해버립니다.


왜 ==는 안 되고 <=는 되는지?
Kotlin에서 **==**는 값 비교를 수행하며, 두 타입이 일치해야 합니다.
즉, Int와 Long을 비교하려면 타입 변환이 일어나지 않기 때문에 타입이 달라서 컴파일 오류가 발생합니다.
반면, **<=**와 같은 비교 연산자는 타입 간 자동 변환을 지원하기 때문에 Int와 Long이 비교될 수 있습니다.





++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
for(i in n downTo 1)에서 i의 타입은 **Long**이 됩니다.

왜 i의 타입이 Long인가?
Kotlin에서 downTo는 Int 타입을 기준으로 동작합니다. 그러나 n이 Long 타입일 경우, downTo는 자동으로 Long으로 변환되지 않고, Int 범위로 간주되기 때문에, 결과적으로 i는 Int로 간주됩니다.

하지만, i를 Long으로 유지하려면, downTo에 Long을 사용해야 합니다.

수정 방법:
Long 타입을 사용하여 i의 타입도 Long으로 지정하려면, n을 Long 타입으로 명시적으로 사용해야 합니다.

수정된 코드:
kotlin
복사
편집
import java.util.Scanner

fun main() = with(Scanner(System.`in`)) {
    val n = nextLong()
    var total = 1L
    when {
        n == 0L -> print(1)
        else -> {
            for (i in n downTo 1L) {  // downTo 1L로 수정
                total *= i
            }
            print(total)
        }
    }
}
주요 변경 사항:
downTo 1L로 1L을 명시적으로 Long 타입으로 변경했습니다. 이렇게 하면 i의 타입이 Long으로 유지됩니다.

결론:
for(i in n downTo 1)에서 i는 기본적으로 Int 타입이 되지만, n이 Long일 때는 downTo를 사용할 때 Long 범위를 명시적으로 지정해야 i가 Long으로 동작합니다.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



